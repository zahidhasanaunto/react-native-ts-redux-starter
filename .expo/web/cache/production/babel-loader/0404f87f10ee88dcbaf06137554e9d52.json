{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import React from'react';import{AppLoading as ExpoAppLoading,SplashScreen}from'expo';import*as Font from'expo-font';import{Asset}from'expo-asset';export var LoadFontsTask=function LoadFontsTask(fonts){return Font.loadAsync(fonts).then(function(){return null;});};export var LoadAssetsTask=function LoadAssetsTask(assets){var tasks=assets.map(function(source){return Asset.fromModule(source).downloadAsync();});return Promise.all(tasks).then(function(){return null;});};SplashScreen.preventAutoHide();export var AppLoading=function AppLoading(props){var _React$useState=React.useState(true),_React$useState2=_slicedToArray(_React$useState,2),loading=_React$useState2[0],setLoading=_React$useState2[1];var loadingResult=props.initialConfig||{};var onTasksFinish=function onTasksFinish(){setLoading(false);SplashScreen.hide();};var saveTaskResult=function saveTaskResult(result){if(result){loadingResult[result[0]]=result[1];}};var createRunnableTask=function createRunnableTask(task){return task().then(saveTaskResult);};var startTasks=function startTasks(){if(props.tasks){return Promise.all(props.tasks.map(createRunnableTask));}return Promise.resolve();};var renderLoadingElement=function renderLoadingElement(){return React.createElement(ExpoAppLoading,{startAsync:startTasks,onFinish:onTasksFinish,autoHideSplash:false});};return React.createElement(React.Fragment,null,loading?renderLoadingElement():props.children(loadingResult),props.placeholder&&props.placeholder({loading:loading}));};","map":{"version":3,"sources":["/home/aunto/Projects/WCL/wcl-app/src/app/app-loading.component.expo.tsx"],"names":["AppLoading","LoadFontsTask","Font","LoadAssetsTask","tasks","assets","Asset","Promise","SplashScreen","loading","setLoading","React","loadingResult","props","onTasksFinish","saveTaskResult","result","createRunnableTask","task","startTasks","renderLoadingElement"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { AppLoading as ExpoAppLoading, SplashScreen } from 'expo';\nimport * as Font from 'expo-font';\nimport { Asset } from 'expo-asset';\n\ntype TaskResult = [string, any];\ntype Task = () => Promise<TaskResult | null>;\n\nexport interface ApplicationLoaderProps {\n  tasks?: Task[];\n  initialConfig?: Record<string, any>;\n  placeholder?: (props: { loading: boolean }) => React.ReactElement;\n  children: (config: any) => React.ReactElement;\n}\n\nexport const LoadFontsTask = (fonts: { [key: string]: number }): Promise<TaskResult> => {\n  return Font.loadAsync(fonts).then(() => null);\n};\n\nexport const LoadAssetsTask = (assets: number[]): Promise<TaskResult> => {\n  const tasks: Promise<void>[] = assets.map((source: number): Promise<void> => {\n    return Asset.fromModule(source).downloadAsync();\n  });\n\n  return Promise.all(tasks).then(() => null);\n};\n\n/*\n * Prevent splash screen from hiding since it is controllable by AppLoading component.\n */\nSplashScreen.preventAutoHide();\n\n/**\n * Loads application configuration and returns content of the application when done.\n *\n * @property {Task[]} tasks - Array of tasks to prepare application before it's loaded.\n * A single task should return a Promise with value and a by which this value is accessible.\n *\n * @property {any} fallback - Fallback configuration that is used as default application configuration.\n * May be useful at first run.\n *\n * @property {(props: { loaded: boolean }) => React.ReactElement} placeholder - Element to render\n * while application is loading.\n *\n * @property {(result: any) => React.ReactElement} children - Should return Application component\n */\nexport const AppLoading = (props: ApplicationLoaderProps): React.ReactElement => {\n\n  const [loading, setLoading] = React.useState<boolean>(true);\n  const loadingResult = props.initialConfig || {};\n\n  const onTasksFinish = (): void => {\n    setLoading(false);\n    SplashScreen.hide();\n  };\n\n  const saveTaskResult = (result: [string, any] | null): void => {\n    if (result) {\n      loadingResult[result[0]] = result[1];\n    }\n  };\n\n  const createRunnableTask = (task: Task): Promise<void> => {\n    return task().then(saveTaskResult);\n  };\n\n  const startTasks = (): Promise<any> => {\n    if (props.tasks) {\n      return Promise.all(props.tasks.map(createRunnableTask));\n    }\n    return Promise.resolve();\n  };\n\n  const renderLoadingElement = (): React.ReactElement => (\n    <ExpoAppLoading\n      startAsync={startTasks}\n      onFinish={onTasksFinish}\n      autoHideSplash={false}\n    />\n  );\n\n  return (\n    <React.Fragment>\n      {loading ? renderLoadingElement() : props.children(loadingResult)}\n      {props.placeholder && props.placeholder({ loading })}\n    </React.Fragment>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}